z <- qnorm(1-alpha/2)
IC.vec <- NULL
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = p, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
}
w[l,] <- howmany(IC.vec,t(beta)%*%XN)$vec
}
w
mean(w)
cbind(IC.vec)
t(beta)%*%XN
####################################
reps <- 10
n <- 10
w <- matrix(NA, nrow=reps,ncol=p)
Xg <- mvrnorm(n, apply(X,2,mean), Sigma = SI)
Xgc <- scale(Xg, center = TRUE, scale=FALSE)
Ytrue <- mean(y) + Xgc%*%beta
alpha <- 0.05
z <- qnorm(1-alpha/2)
IC.vec <- NULL
p <- dim(X)[2]
####################################
SIhat <- cov(X)
shat <- cov(X,y)
sts <- as.numeric((t(shat)%*%shat))
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p]
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat
SI <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
####################################
reps <- 10
n <- 10
w <- matrix(NA, nrow=reps,ncol=p)
Xg <- mvrnorm(n, apply(X,2,mean), Sigma = SI)
Xgc <- scale(Xg, center = TRUE, scale=FALSE)
Ytrue <- mean(y) + Xgc%*%beta
alpha <- 0.05
z <- qnorm(1-alpha/2)
IC.vec <- NULL
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = p, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
}
w[l,] <- howmany(IC.vec,t(beta)%*%XN)$vec
}
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = p, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
}
w[l,] <- howmany(IC.vec,t(beta)%*%XN)$vec
}
IC.vec <- NULL
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = n, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
}
w[l,] <- howmany(IC.vec,t(beta)%*%XN)$vec
}
IC.vec
t(beta)%*%XN
mean(w)
t(beta)%*%XN
t(beta)%*%XN in c(109,112)
####################################
reps <- 10
n <- 10
w <- matrix(NA, nrow=reps,ncol=p)
Xg <- mvrnorm(n, apply(X,2,mean), Sigma = SI)
Xgc <- scale(Xg, center = TRUE, scale=FALSE)
Ytrue <- mean(y) + Xgc%*%beta
alpha <- 0.05
z <- qnorm(1-alpha/2)
IC.vec <- NULL
w <- 0
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = n, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
if (IC[1] <= t(beta)%*%XN & t(beta)%*%XN<=IC[2]){w <- w+1}
}
}
w
n
####################################
reps <- 10
n <- 10
w <- matrix(NA, nrow=reps,ncol=n)
Xg <- mvrnorm(n, apply(X,2,mean), Sigma = SI)
Xgc <- scale(Xg, center = TRUE, scale=FALSE)
Ytrue <- mean(y) + Xgc%*%beta
alpha <- 0.05
z <- qnorm(1-alpha/2)
IC.vec <- NULL
val <- NULL
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = n, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
val <- t(beta)%*%XN
}
w[l,] <- howmany(IC.vec,beta)$vec
}
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = n, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
val <- t(beta)%*%XN
}
w[l,] <- howmany(IC.vec,val)$vec
}
val
####################################
reps <- 10
n <- 10
w <- matrix(NA, nrow=reps,ncol=n)
Xg <- mvrnorm(n, apply(X,2,mean), Sigma = SI)
Xgc <- scale(Xg, center = TRUE, scale=FALSE)
Ytrue <- mean(y) + Xgc%*%beta
alpha <- 0.05
z <- qnorm(1-alpha/2)
IC.vec <- NULL
val <- NULL
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = n, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
val[i] <- t(beta)%*%XN
}
w[l,] <- howmany(IC.vec,val)$vec
}
val
IC.vec
w
mean(w)
warning()
w[l,] <- howmany(IC.vec,val)$vec
w
cbind(IC.vec,val)
####################################
reps <- 50
n <- 10
w <- matrix(NA, nrow=reps,ncol=n)
Xg <- mvrnorm(n, apply(X,2,mean), Sigma = SI)
Xgc <- scale(Xg, center = TRUE, scale=FALSE)
Ytrue <- mean(y) + Xgc%*%beta
alpha <- 0.05
z <- qnorm(1-alpha/2)
IC.vec <- NULL
val <- NULL
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = n, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
val[i] <- t(beta)%*%XN
}
w[l,] <- howmany(IC.vec,val)$vec
}
mean(w)
w
####################################
reps <- 500
n <- 10
w <- matrix(NA, nrow=reps,ncol=n)
Xg <- mvrnorm(n, apply(X,2,mean), Sigma = SI)
Xgc <- scale(Xg, center = TRUE, scale=FALSE)
Ytrue <- mean(y) + Xgc%*%beta
alpha <- 0.05
z <- qnorm(1-alpha/2)
IC.vec <- NULL
val <- NULL
for (l in 1:reps){
cat("l =",l,"\n")
Ysimu <- rnorm(n, Ytrue, tau)
sig <- SI%*%beta
sigmay2 <- tau^2 + as.numeric(t(beta)%*%SI%*%beta)
Omega <- as.numeric(t(sig)%*%SI%*%sig/((t(sig)%*%sig)))
IC.vec <- matrix(data = NA, nrow = n, ncol = 2)
for (i in 1:n){
#cat("i =",i,"\n")
mod <- plsr(Ysimu~Xg, 1)
betahat <- mod$coefficients[,1,1]
shat <- cov(Xg,Ysimu)
sts <- as.numeric((t(shat)%*%shat))
sigma.0hat <- qr.Q(qr(shat),complete=TRUE)[,2:p] # px(p-1)
SIhat <- cov(Xg)
Omegahat <- as.numeric(t(shat)%*%SIhat%*%shat/sts)
Omega0hat <- t(sigma.0hat)%*%SIhat%*%sigma.0hat # (p-1)x(p-1)
SIhat2 <- (Omegahat/sts)*(shat%*%t(shat)) + sigma.0hat%*%Omega0hat%*%t(sigma.0hat)
sigmaY2hat <- var(Ysimu)
XN <- Xg[i,]
Vhat <- as.numeric((Omegahat^(-2)/n)*t(XN)%*%(SIhat2*sigmaY2hat - shat%*%t(shat))%*%XN)
IC <- t(betahat)%*%XN + c(-1,1)*z*Vhat^(1/2)
IC.vec[i,] <- IC
val[i] <- t(beta)%*%XN
}
w[l,] <- howmany(IC.vec,val)$vec
}
mean(w)
mean(w)
library(pls)
library(plsr)
# predictores L,H,S,W
musselslog <- read.csv("C:/Users/Jero/Dropbox/PLS Paper/Mussel/musselslogMinus3.txt", sep="")
attach(musselslog)
y <- logM
Xp <- musselslog[,-3]
X <- as.matrix(Xp)
p <- dim(X)[2]
n <- length(y)
m <- n-1
y1 <- y-mean(y)
X1 <- scale(X,center=TRUE,scale=FALSE)
#modM <- plsr(y1~X1, ncomp = 1)
modM <- plsr(y~X, ncomp = 1)
# Y vs pred
plot(y,modM$fitted.values,main="y vs fitted values with the full model",pch=19)
abline(0,1,col="blue",lwd=2)
scatterplot(modM$fitted.values, modO$fitted.values,boxplots = FALSE,
smooth = FALSE,pch=20,ylab="",xlab="",
main="PLS fitted values vs OLS fitted values", col = "black",grid=FALSE)
abline(0,1,col="blue",lwd=2)
#modM <- plsr(y1~X1, ncomp = 1)
modM <- plsr(y~X, ncomp = 1)
# PLS vs OLS
alpha <- 0.05
modM <- plsr(y~X, ncomp = 1)
modO <- lm(y~X)
scatterplot(modM$fitted.values, modO$fitted.values,boxplots = FALSE,
smooth = FALSE,pch=20,ylab="",xlab="",
main="PLS fitted values vs OLS fitted values", col = "black",grid=FALSE)
abline(0,1,col="blue",lwd=2)
library(car)
scatterplot(modM$fitted.values, modO$fitted.values,boxplots = FALSE,
smooth = FALSE,pch=20,ylab="",xlab="",
main="PLS fitted values vs OLS fitted values", col = "black",grid=FALSE)
abline(0,1,col="blue",lwd=2)
setwd("C:/Users/Jero/Dropbox/PLS Paper/Mussel")
pdf("plsvsols.pdf", height=8, width=12)
scatterplot(modM$fitted.values, modO$fitted.values,boxplots = FALSE,
smooth = FALSE,pch=20,ylab="",xlab="",
main="PLS fitted values vs OLS fitted values", col = "black",grid=FALSE)
abline(0,1,col="blue",lwd=2)
dev.off()
pdf("plsvsols.pdf", height=4, width=8)
scatterplot(modM$fitted.values, modO$fitted.values,boxplots = FALSE,
smooth = FALSE,pch=20,ylab="",xlab="",
main="PLS fitted values vs OLS fitted values", col = "black",grid=FALSE)
abline(0,1,col="blue",lwd=2)
dev.off()
library(pls)
library(plsr)
library(car)
# predictores L,H,S,W
musselslog <- read.csv("C:/Users/Jero/Dropbox/PLS Paper/Mussel/musselslogMinus3.txt", sep="")
attach(musselslog)
y <- logM
Xp <- musselslog[,-3]
X <- as.matrix(Xp)
p <- dim(X)[2]
n <- length(y)
m <- n-1
y1 <- y-mean(y)
X1 <- scale(X,center=TRUE,scale=FALSE)
musselslog <- read.csv("C:/Users/admin/Dropbox/PLS Paper/Mussel/musselslogMinus3.txt", sep="")
View(musselslog)
attach(musselslog)
y <- logM
Xp <- musselslog[,-3]
X <- as.matrix(Xp)
p <- dim(X)[2]
n <- length(y)
m <- n-1
y1 <- y-mean(y)
X1 <- scale(X,center=TRUE,scale=FALSE)
install.packages("latex2exp")
library(latex2exp)
pdf("yvsfitted.pdf", bg = "transparent", width = 8, height = 6)
modM <- plsr(y~X, ncomp = 1)
plot(y,modM$fitted.values,main="",
pch=19,xlab="",ylab=TeX('$Y_i$'),ylab=TeX('$\hat{Y}_i$'))
abline(0,1,col="blue",lwd=2)
dev.off()
modM <- plsr(y~X, ncomp = 1)
plot(y,modM$fitted.values,main="",
pch=19,xlab="",ylab=TeX('$Y_i$'),ylab=TeX('$\hat{Y}_i$'))
plot(y,modM$fitted.values,main="",
pch=19,xlab="",ylab=TeX('$Y_i$'),xlab=TeX('$\hat{Y}_i$'))
plot(y,modM$fitted.values,main="",
pch=19,xlab="",ylab=TeX("$Y_i$"),xlab=TeX("$\hat{Y}_i$"))
plot(y,modM$fitted.values,main="",
pch=19,xlab="",ylab=TeX("$Y_i$"),xlab=TeX("$\\hat{Y}_i$"))
plot(y,modM$fitted.values,main="",
pch=19,ylab=TeX("$Y_i$"),xlab=TeX("$\\hat{Y}_i$"))
pdf("yvsfitted.pdf", bg = "transparent", width = 8, height = 6)
plot(y,modM$fitted.values,main="",
pch=19,ylab=TeX("$Y_i$"),xlab=TeX("$\\hat{Y}_i$"))
abline(0,1,col="blue",lwd=2)
dev.off()
modM <- plsr(y~X, ncomp = 1)
modO <- lm(y~X)
pdf("plsvsols.pdf", bg = "transparent", width = 8, height = 6)
scatterplot(modM$fitted.values, modO$fitted.values,boxplots = FALSE,
smooth = FALSE,pch=20,ylab="",xlab="",
main="PLS fitted values vs OLS fitted values", col = "black",grid=FALSE)
abline(0,1,col="blue",lwd=2)
dev.off()
plot(modM$fitted.values,y,main="",
pch=19,ylab=TeX("$Y_i$"),xlab=TeX("$\\hat{Y}_i$"))
abline(0,1,col="blue",lwd=2)
pdf("yvsfitted.pdf", bg = "transparent", width = 8, height = 6)
plot(modM$fitted.values,y,main="",
pch=19,ylab=TeX("$Y_i$"),xlab=TeX("$\\hat{Y}_i$"))
abline(0,1,col="blue",lwd=2)
dev.off()
library(pls)
library(plsr)
library(car)
# predictores L,H,S,W
musselslog <- read.csv("C:/Users/Jero/Dropbox/PLS Paper/Mussel/musselslogMinus3.txt", sep="")
attach(musselslog)
library(latex2exp)
musselslog <- read.csv("C:/Users/admin/Dropbox/PLS Paper/Mussel/musselslogMinus3.txt", sep="")
View(musselslog)
attach(musselslog)
library(latex2exp)
y <- logM
Xp <- musselslog[,-3]
X <- as.matrix(Xp)
p <- dim(X)[2]
n <- length(y)
m <- n-1
y1 <- y-mean(y)
X1 <- scale(X,center=TRUE,scale=FALSE)
View(Xp)
Xp
